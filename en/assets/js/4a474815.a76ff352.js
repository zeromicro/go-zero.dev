"use strict";(self.webpackChunktmp=self.webpackChunktmp||[]).push([[6907],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(t),h=o,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||i;return t?a.createElement(m,r(r({ref:n},d),{},{components:t})):a.createElement(m,r({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=p;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},4421:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return d},default:function(){return p}});var a=t(7462),o=t(3366),i=(t(7294),t(3905)),r=["components"],l={sidebar_position:7},c="Load Balancer",s={unversionedId:"component/balance",id:"component/balance",title:"Load Balancer",description:"Background",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/component/balance.md",sourceDirName:"component",slug:"/component/balance",permalink:"/go-zero.dev/en/docs/component/balance",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Overload Protection",permalink:"/go-zero.dev/en/docs/component/load"},next:{title:"Discovery",permalink:"/go-zero.dev/en/docs/component/discovery"}},d=[{value:"Background",id:"background",children:[],level:3},{value:"The core idea of the algorithm",id:"the-core-idea-of-the-algorithm",children:[{value:"p2c",id:"p2c",children:[],level:4},{value:"EWMA",id:"ewma",children:[],level:4},{value:"EWMA Advantages of the algorithm",id:"ewma-advantages-of-the-algorithm",children:[],level:4},{value:"\u03b2 calculation",id:"\u03b2-calculation",children:[],level:4}],level:3},{value:"Implementing a custom load balancer in gRPC",id:"implementing-a-custom-load-balancer-in-grpc",children:[],level:3},{value:"The main logic of go-zero&#39;s load balancing implementation",id:"the-main-logic-of-go-zeros-load-balancing-implementation",children:[],level:3},{value:"Load Balancing Code Analysis",id:"load-balancing-code-analysis",children:[{value:"Save all node information of the service",id:"save-all-node-information-of-the-service",children:[],level:4},{value:"<code>p2cPicker</code> implements the <code>balancer.Picker</code> interface, and <code>conns</code> holds information about all nodes of the service",id:"p2cpicker-implements-the-balancerpicker-interface-and-conns-holds-information-about-all-nodes-of-the-service",children:[],level:4},{value:"<code>gRPC</code> calls the <code>Build</code> method when a node is updated, passing in all the node information, where we save each node information in a subConn structure. Here we save each node information in a subConn structure and merge them together in a <code>p2cPicker</code> structure",id:"grpc-calls-the-build-method-when-a-node-is-updated-passing-in-all-the-node-information-where-we-save-each-node-information-in-a-subconn-structure-here-we-save-each-node-information-in-a-subconn-structure-and-merge-them-together-in-a-p2cpicker-structure",children:[],level:4},{value:"Randomly selected node information is divided into three cases here:",id:"randomly-selected-node-information-is-divided-into-three-cases-here",children:[],level:4},{value:"<code>load</code> calculates the load of the node",id:"load-calculates-the-load-of-the-node",children:[],level:4},{value:"End of request, update information such as <code>EWMA</code> of the node",id:"end-of-request-update-information-such-as-ewma-of-the-node",children:[],level:4}],level:3}],u={toc:d};function p(e){var n=e.components,l=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"load-balancer"},"Load Balancer"),(0,i.kt)("h3",{id:"background"},"Background"),(0,i.kt)("p",null,"When selecting a load balancing algorithm, we want to meet the following requirements."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Have partitioning and server room scheduling affinity",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Choose the node with the lowest load possible each time"),(0,i.kt)("li",{parentName:"ul"},"Select the fastest responsive node possible each time"))),(0,i.kt)("li",{parentName:"ul"},"No need for manual intervention on failed nodes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When a node fails, the load balancing algorithm can automatically isolate the node"),(0,i.kt)("li",{parentName:"ul"},"When a failed node recovers, traffic distribution to that node can be automatically resumed")))),(0,i.kt)("p",null,"Translated with ",(0,i.kt)("a",{parentName:"p",href:"http://www.DeepL.com/Translator"},"www.DeepL.com/Translator")," (free version)"),(0,i.kt)("h3",{id:"the-core-idea-of-the-algorithm"},"The core idea of the algorithm"),(0,i.kt)("h4",{id:"p2c"},"p2c"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"p2c")," (Pick Of 2 Choices) Choose one of two: Randomly select two nodes among multiple nodes."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"go-zero")," in will be randomly selected 3 times, and if the health condition of one of the selected nodes meets the requirement, the selection is interrupted and both nodes are adopted."),(0,i.kt)("h4",{id:"ewma"},"EWMA"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EWMA")," (Exponentially Weighted Moving-Average) Exponential Moving Weighted Average: The weighting factor of each value decreases exponentially over time, and the closer the value is to the current moment, the larger the weighting factor is, reflecting the average value over the most recent period."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Formula\uff1a")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ewma",src:t(2253).Z})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Variable Explanation\uff1a",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Vt: represents the EWMA value of the tth request"),(0,i.kt)("li",{parentName:"ul"},"Vt-1: represents the EWMA value of the t-1st request"),(0,i.kt)("li",{parentName:"ul"},"\u03b2: is a constant")))),(0,i.kt)("h4",{id:"ewma-advantages-of-the-algorithm"},"EWMA Advantages of the algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Compared to the common algorithm for calculating average values, EWMA does not need to save all the past values, which significantly reduces the amount of computation and storage resources.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The traditional algorithm for calculating the average is not sensitive to the network time consumption, while EWMA can adjust \u03b2 by the frequency of requests to quickly monitor the network burr or more reflect the overall average."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When the requests are more frequent, it means that the node network load is increasing, and we want to monitor the node processing time (which reflects the node load), we adjust \u03b2 down accordingly. \u03b2 is smaller, the EWMA value is closer to this time, and then we can quickly monitor the network burr;"),(0,i.kt)("li",{parentName:"ul"},"When the requests are less frequent, we adjust the \u03b2 value relatively larger. In this way, the calculated EWMA value is closer to the average value.")))),(0,i.kt)("h4",{id:"\u03b2-calculation"},"\u03b2 calculation"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"go-zero")," uses the decay function model from Newton's cooling law to calculate the ",(0,i.kt)("inlineCode",{parentName:"p"},"\u03b2")," value in the ",(0,i.kt)("inlineCode",{parentName:"p"},"EWMA")," algorithm:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ewma",src:t(7006).Z})),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"\u0394t")," is the interval between two requests, ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," are constants"),(0,i.kt)("h3",{id:"implementing-a-custom-load-balancer-in-grpc"},"Implementing a custom load balancer in gRPC"),(0,i.kt)("p",null,"First we need to implement google.golang.org/grpc/balancer/base/base.go/PickerBuilder interface, this interface is when there is a service node update will call the interface's Build method"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="grpc-go/balancer/base/base.go"',title:'"grpc-go/balancer/base/base.go"'},"\ntype PickerBuilder interface {\n    // Build returns a picker that will be used by gRPC to pick a SubConn.\n    Build(info PickerBuildInfo) balancer.Picker\n}\n\n")),(0,i.kt)("p",null,"It also implements the google.golang.org/grpc/balancer/balancer.go/Picker interface. This interface mainly implements load balancing, picking a node for requests"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="grpc-go/balancer/balancer.go"',title:'"grpc-go/balancer/balancer.go"'},"\ntype Picker interface {\n  Pick(info PickInfo) (PickResult, error)\n}\n\n")),(0,i.kt)("p",null,"Finally, register our implemented load balancer with the load balancing map"),(0,i.kt)("h3",{id:"the-main-logic-of-go-zeros-load-balancing-implementation"},"The main logic of go-zero's load balancing implementation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"At each node update, ",(0,i.kt)("inlineCode",{parentName:"p"},"gRPC")," will call the ",(0,i.kt)("inlineCode",{parentName:"p"},"Build")," method, where all the node information is stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"Build"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"gRPC")," calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pick")," method to fetch nodes when it fetches nodes to process requests. ",(0,i.kt)("inlineCode",{parentName:"p"},"go-zero")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"p2c")," algorithm in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pick")," method to pick the node and calculate the load from the ",(0,i.kt)("inlineCode",{parentName:"p"},"EWMA")," value of the node and return the node with low load for gRPC to use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"At the end of the request ",(0,i.kt)("inlineCode",{parentName:"p"},"gRPC")," calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"PickResult.Done")," method, in which ",(0,i.kt)("inlineCode",{parentName:"p"},"go-zero")," stores the information about the time spent on this request and calculates the ",(0,i.kt)("inlineCode",{parentName:"p"},"EWMA")," value and saves it for the next request to calculate the load and so on."))),(0,i.kt)("h3",{id:"load-balancing-code-analysis"},"Load Balancing Code Analysis"),(0,i.kt)("h4",{id:"save-all-node-information-of-the-service"},"Save all node information of the service"),(0,i.kt)("p",null,"We need to keep information about the time taken by the node to process this request, ",(0,i.kt)("inlineCode",{parentName:"p"},"EWMA"),", etc. ",(0,i.kt)("inlineCode",{parentName:"p"},"go-zero")," has designed the following structure for each node."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="go-zero/zrpc/internal/balancer/p2c/p2c.go"',title:'"go-zero/zrpc/internal/balancer/p2c/p2c.go"'},"\ntype subConn struct {\n    addr     resolver.Address\n    conn     balancer.SubConn\n    lag      uint64 // Used to save ewma values\n    inflight int64  // Used to keep the total number of requests being processed by the current node\n    success  uint64 // Used to identify the health status of this connection over time\n    requests int64  // Used to store the total number of requests\n    last     int64  // Used to save the last request time, used to calculate the ewma value\n    pick     int64  // Save the last selected point in time\n}\n\n")),(0,i.kt)("h4",{id:"p2cpicker-implements-the-balancerpicker-interface-and-conns-holds-information-about-all-nodes-of-the-service"},(0,i.kt)("inlineCode",{parentName:"h4"},"p2cPicker")," implements the ",(0,i.kt)("inlineCode",{parentName:"h4"},"balancer.Picker")," interface, and ",(0,i.kt)("inlineCode",{parentName:"h4"},"conns")," holds information about all nodes of the service"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="go-zero/zrpc/internal/balancer/p2c/p2c.go"',title:'"go-zero/zrpc/internal/balancer/p2c/p2c.go"'},"\ntype p2cPicker struct {\n  conns []*subConn  // Save information about all nodes \n  r     *rand.Rand\n  stamp *syncx.AtomicDuration\n  lock  sync.Mutex\n}\n\n")),(0,i.kt)("h4",{id:"grpc-calls-the-build-method-when-a-node-is-updated-passing-in-all-the-node-information-where-we-save-each-node-information-in-a-subconn-structure-here-we-save-each-node-information-in-a-subconn-structure-and-merge-them-together-in-a-p2cpicker-structure"},(0,i.kt)("inlineCode",{parentName:"h4"},"gRPC")," calls the ",(0,i.kt)("inlineCode",{parentName:"h4"},"Build")," method when a node is updated, passing in all the node information, where we save each node information in a subConn structure. Here we save each node information in a subConn structure and merge them together in a ",(0,i.kt)("inlineCode",{parentName:"h4"},"p2cPicker")," structure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="go-zero/zrpc/internal/balancer/p2c/p2c.go:42"',title:'"go-zero/zrpc/internal/balancer/p2c/p2c.go:42"'},"\nfunc (b *p2cPickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker {\n  ......\n  var conns []*subConn\n  for conn, connInfo := range readySCs {\n    conns = append(conns, &subConn{\n      addr:    connInfo.Address,\n      conn:    conn,\n      success: initSuccess,\n    })\n  }\n  return &p2cPicker{\n    conns: conns,\n    r:     rand.New(rand.NewSource(time.Now().UnixNano())),\n    stamp: syncx.NewAtomicDuration(),\n  }\n}\n\n")),(0,i.kt)("h4",{id:"randomly-selected-node-information-is-divided-into-three-cases-here"},"Randomly selected node information is divided into three cases here:"),(0,i.kt)("p",null,"The main implementation code is as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="go-zero/zrpc/internal/balancer/p2c/p2c.go:80"',title:'"go-zero/zrpc/internal/balancer/p2c/p2c.go:80"'},"\nswitch len(p.conns) {\n  case 0: // No node, return error\n    return emptyPickResult, balancer.ErrNoSubConnAvailable\n  case 1: // There is a node, return this node directly\n    chosen = p.choose(p.conns[0], nil)\n  case 2: // There are two nodes, calculate the load and return the node with the lower load\n    chosen = p.choose(p.conns[0], p.conns[1])\n  default: // There are multiple nodes, p2c picks two nodes, compares the load of these two nodes, and returns the node with the lower load\n    var node1, node2 *subConn\n    // 3 times random selection of two nodes\n    for i := 0; i < pickTimes; i++ {\n      a := p.r.Intn(len(p.conns))\n      b := p.r.Intn(len(p.conns) - 1)\n      if b >= a {\n        b++\n      }\n      node1 = p.conns[a]\n      node2 = p.conns[b]\n      // If the selected node meets the health requirements this time, break the selection\n      if node1.healthy() && node2.healthy() {\n        break\n      }\n    }\n    // Compare the load of the two nodes and choose the one with the lower load\n    chosen = p.choose(node1, node2)\n  }\n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There is only one service node, which is returned directly for gRPC use")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There are two service nodes, calculate the load by EWMA value, and return the node with low load for gRPC")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With multiple service nodes, two nodes are selected by the p2c algorithm, the load is compared, and the node with the lower load is returned for gRPC"))),(0,i.kt)("h4",{id:"load-calculates-the-load-of-the-node"},(0,i.kt)("inlineCode",{parentName:"h4"},"load")," calculates the load of the node"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"choose")," method above will call the ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," method to calculate the node load."),(0,i.kt)("p",null,"The formula for calculating the load is: ",(0,i.kt)("inlineCode",{parentName:"p"},"load = ewma * inflight")),(0,i.kt)("p",null,"Here is a brief explanation: ",(0,i.kt)("inlineCode",{parentName:"p"},"ewma")," is the average request time, ",(0,i.kt)("inlineCode",{parentName:"p"},"inflight")," is the number of requests being processed by the current node, and multiplying them together roughly calculates the network load of the current node."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"\nfunc (c *subConn) load() int64 {\n  // Calculate the load of the node by EWMA; add 1 to avoid the case of 0\n  lag := int64(math.Sqrt(float64(atomic.LoadUint64(&c.lag) + 1)))\n  load := lag * (atomic.LoadInt64(&c.inflight) + 1)\n  if load == 0 {\n    return penalty\n  }\n  return load\n}\n\n")),(0,i.kt)("h4",{id:"end-of-request-update-information-such-as-ewma-of-the-node"},"End of request, update information such as ",(0,i.kt)("inlineCode",{parentName:"h4"},"EWMA")," of the node"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"\nfunc (p *p2cPicker) buildDoneFunc(c *subConn) func(info balancer.DoneInfo) {\n  start := int64(timex.Now())\n  return func(info balancer.DoneInfo) {\n    // Number of requests being processed minus 1\n    atomic.AddInt64(&c.inflight, -1)\n    now := timex.Now()\n    // Save the time point at the end of this request and retrieve the time point at the last request\n    last := atomic.SwapInt64(&c.last, int64(now))\n    td := int64(now) - last\n    if td < 0 {\n      td = 0\n    }\n    // Calculation of \u03b2 in EWMA algorithm using the decay function model in Newton's cooling law\n    w := math.Exp(float64(-td) / float64(decayTime))\n    // Save the elapsed time of this request\n    lag := int64(now) - start\n    if lag < 0 {\n      lag = 0\n    }\n    olag := atomic.LoadUint64(&c.lag)\n    if olag == 0 {\n      w = 0\n    }\n    // Calculating EWMA values\n    atomic.StoreUint64(&c.lag, uint64(float64(olag)*w+float64(lag)*(1-w)))\n    success := initSuccess\n    if info.Err != nil && !codes.Acceptable(info.Err) {\n      success = 0\n    }\n    osucc := atomic.LoadUint64(&c.success)\n    atomic.StoreUint64(&c.success, uint64(float64(osucc)*w+float64(success)*(1-w)))\n\n    stamp := p.stamp.Load()\n    if now-stamp >= logInterval {\n      if p.stamp.CompareAndSwap(stamp, now) {\n        p.logStats()\n      }\n    }\n  }\n}\n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Subtract 1 from the total number of requests being processed by the node"),(0,i.kt)("li",{parentName:"ul"},"Save the time point at which the processing of the request ended, which is used to calculate the difference between the last request processed by the node and to calculate the \u03b2 value in the EWMA"),(0,i.kt)("li",{parentName:"ul"},"calculate the time taken for this request and calculate the EWMA value and save it to the lag attribute of the node"),(0,i.kt)("li",{parentName:"ul"},"Calculates the health status of the node and stores it in the success attribute of the node")))}p.isMDXComponent=!0},2253:function(e,n,t){n.Z=t.p+"assets/images/ewma-e7d58d4396f07ed4b07dae5f88b6912f.png"},7006:function(e,n,t){n.Z=t.p+"assets/images/\u03b2-c79d184dbc37ca4b6e6c69132a3fcf5f.png"}}]);